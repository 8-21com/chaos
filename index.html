<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>RSIC Season 2 Dashboard</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    body {
      background-color: #121212;
      color: #f0f0f0;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      height: 100vh;
      overflow: hidden;
      position: relative;
    }
    .container {
      position: relative;
      width: 100%;
      height: 100%;
    }
    .title {
      position: absolute;
      top: 20px;
      width: 100%;
      text-align: center;
      font-size: 1.5rem;
      font-weight: bold;
      letter-spacing: 2px;
      color: #f0f0f0;
      z-index: 5;
      pointer-events: none;
      text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
    }
    button {
      position: absolute;
      padding: 1rem 2rem;
      font-size: 1.1rem;
      background-color: rgba(40, 40, 40, 0.6);
      color: #f0f0f0;
      border: 1px solid #f0f0f0;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.2s ease;
      opacity: 0.8;
      z-index: 10;
      box-shadow: 0 0 15px rgba(255, 255, 255, 0.2);
      text-shadow: 0 0 5px rgba(255, 255, 255, 0.5);
    }
    
    /* Trail effect element */
    .button-trail {
      position: absolute;
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background-color: rgba(255, 255, 255, 0.3);
      pointer-events: none;
      z-index: 9;
    }
  </style>
</head>
<body>
  <div class="container" id="container">
    <div class="title">RSIC SEASON II: CHAOS</div>
    <button id="launchBtn">Launch Season 2 Dashboard</button>
    <div id="trailContainer"></div>
  </div>
  <script>
    // Wait for DOM to be fully loaded
    document.addEventListener('DOMContentLoaded', function() {
      const button = document.getElementById("launchBtn");
      const container = document.getElementById("container");
      
      // Make sure button is found
      if (!button) {
        console.error("Button not found!");
        return;
      }
      
      // Set initial position with a slight delay to ensure dimensions are calculated
      setTimeout(function() {
        setInitialPosition();
      }, 100);
      
      function setInitialPosition() {
        const buttonWidth = button.offsetWidth;
        const buttonHeight = button.offsetHeight;
        
        button.style.position = "absolute";
        button.style.left = `${window.innerWidth / 2 - buttonWidth / 2}px`;
        button.style.top = `${window.innerHeight / 2 - buttonHeight / 2}px`;
        
        // Make button visible if it was hidden
        button.style.opacity = "0.8";
      }
      
      // Touch interaction handling
      let lastTouchX = 0;
      let lastTouchY = 0;
      let touchVelocityX = 0;
      let touchVelocityY = 0;
      let touchActive = false;
      
      function updateTouchVelocity(currentX, currentY) {
        touchVelocityX = currentX - lastTouchX;
        touchVelocityY = currentY - lastTouchY;
        lastTouchX = currentX;
        lastTouchY = currentY;
      }
      
      function evadeTouchOrCursor(clientX, clientY, isTouch) {
        // Update the appropriate velocity tracker
        if (isTouch) {
          updateTouchVelocity(clientX, clientY);
        } else {
          updateMouseVelocity(clientX, clientY);
        }
        
        const btnRect = button.getBoundingClientRect();
        const btnX = btnRect.left + btnRect.width / 2;
        const btnY = btnRect.top + btnRect.height / 2;
        
        const distX = clientX - btnX;
        const distY = clientY - btnY;
        const distance = Math.sqrt(distX * distX + distY * distY);
        
        // Increased detection radius for touch (since fingers are less precise)
        const maxDist = isTouch ? 450 : 350;
        
        if (distance < maxDist) {
          // Calculate angle between pointer and button
          const angle = Math.atan2(distY, distX);
          
          // Add jitter based on distance (more erratic when closer)
          const jitterAmount = (maxDist - distance) / maxDist * (isTouch ? 30 : 20);
          const jitterX = (Math.random() * 2 - 1) * jitterAmount;
          const jitterY = (Math.random() * 2 - 1) * jitterAmount;
          
          // Calculate base movement (exponentially stronger when closer)
          const distanceFactor = 1 - distance / maxDist;
          const exponentialFactor = Math.pow(distanceFactor, 2) * (isTouch ? 6 : 4); // Stronger for touch
          const moveFactor = Math.min(isTouch ? 150 : 120, maxDist * exponentialFactor);
          
          // Add anticipatory evasion (move away from pointer's predicted path)
          const velocityX = isTouch ? touchVelocityX : mouseVelocityX;
          const velocityY = isTouch ? touchVelocityY : mouseVelocityY;
          const predictiveX = -Math.sign(velocityX) * Math.abs(velocityX) * (isTouch ? 5 : 3);
          const predictiveY = -Math.sign(velocityY) * Math.abs(velocityY) * (isTouch ? 5 : 3);
          
          // Combine all movement factors
          const moveX = -Math.cos(angle) * moveFactor + jitterX + predictiveX;
          const moveY = -Math.sin(angle) * moveFactor + jitterY + predictiveY;
          
          // Update position
          let newLeft = btnRect.left + moveX;
          let newTop = btnRect.top + moveY;
          
          // Clamp to window bounds with padding
          const padding = 20;
          newLeft = Math.max(padding, Math.min(window.innerWidth - btnRect.width - padding, newLeft));
          newTop = Math.max(padding, Math.min(window.innerHeight - btnRect.height - padding, newTop));
          
          // Apply new position with dynamic transition - faster for touch
          const transitionSpeed = Math.max(0.01, Math.min(isTouch ? 0.1 : 0.15, distance / 1000));
          button.style.transition = `left ${transitionSpeed}s ease, top ${transitionSpeed}s ease`;
          button.style.left = `${newLeft}px`;
          button.style.top = `${newTop}px`;
          
          // Change button opacity based on proximity
          const opacityValue = 0.5 + (distance / maxDist) * 0.5;
          button.style.opacity = opacityValue.toString();
          
          // Teleport if very close or when pointer is moving fast
          const pointerSpeed = Math.sqrt(velocityX * velocityX + velocityY * velocityY);
          const teleportThreshold = isTouch ? 120 : 80; // Larger threshold for touch
          const speedThreshold = isTouch ? 10 : 15;
          if (distance < teleportThreshold || (distance < (isTouch ? 200 : 150) && pointerSpeed > speedThreshold)) {
            teleportRandomly(isTouch ? clientX : null, isTouch ? clientY : null);
          }
        } else {
          // Reset opacity when far away
          button.style.opacity = "0.8";
        }
      }
      
      function evadeCursor(e) {
        if (!isTouchDevice()) {
          evadeTouchOrCursor(e.clientX, e.clientY, false);
        }
      }
      
      function handleTouchStart(e) {
        touchActive = true;
        if (e.touches && e.touches[0]) {
          lastTouchX = e.touches[0].clientX;
          lastTouchY = e.touches[0].clientY;
          evadeTouchOrCursor(lastTouchX, lastTouchY, true);
        }
      }
      
      function handleTouchMove(e) {
        if (touchActive && e.touches && e.touches[0]) {
          evadeTouchOrCursor(e.touches[0].clientX, e.touches[0].clientY, true);
        }
      }
      
      function handleTouchEnd() {
        touchActive = false;
        touchVelocityX = 0;
        touchVelocityY = 0;
      }
      
      function teleportRandomly(touchX, touchY) {
        const buttonWidth = button.offsetWidth;
        const buttonHeight = button.offsetHeight;
        const padding = 20;
        
        const maxX = window.innerWidth - buttonWidth - padding * 2;
        const maxY = window.innerHeight - buttonHeight - padding * 2;
        
        // Get pointer position to avoid teleporting near it
        const pointerX = touchX !== null ? touchX : lastMouseX;
        const pointerY = touchY !== null ? touchY : lastMouseY;
        
        // Try up to 5 times to find a position away from the pointer
        let randX, randY, distanceToPointer;
        let attempts = 0;
        let minDistanceRequired = touchX !== null ? 250 : 200; // Greater distance for touch
        
        do {
          randX = padding + Math.random() * maxX;
          randY = padding + Math.random() * maxY;
          
          const dx = pointerX - randX;
          const dy = pointerY - randY;
          distanceToPointer = Math.sqrt(dx * dx + dy * dy);
          
          attempts++;
          // Reduce required distance if we can't find a good spot after attempts
          if (attempts > 5) {
            minDistanceRequired *= 0.8;
            attempts = 0;
          }
        } while (distanceToPointer < minDistanceRequired && attempts < 10);
        
        // Apply teleportation with a flash effect
        button.style.transition = "none";
        button.style.opacity = "0.2";
        button.style.left = `${randX}px`;
        button.style.top = `${randY}px`;
        
        // Restore opacity after teleport
        setTimeout(() => {
          button.style.transition = "opacity 0.3s ease";
          button.style.opacity = "0.8";
        }, 50);
      }
      
      function isTouchDevice() {
        return 'ontouchstart' in window || navigator.maxTouchPoints > 0;
      }
      
      // Event listeners - use capture phase for more reliable event handling
      document.addEventListener("mousemove", evadeCursor, true);
      
      button.addEventListener("mouseenter", function() {
        if (!isTouchDevice()) {
          teleportRandomly();
        }
      }, true);
      
      container.addEventListener("touchstart", function() {
        teleportRandomly();
      }, true);
      
      // Handle window resize
      window.addEventListener("resize", setInitialPosition);
      
      // Force reposition after a second to handle any edge cases
      setTimeout(setInitialPosition, 1000);
    });
  </script>
</body>
</html>
